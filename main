import logging
import sqlite3
import random
import asyncio
from datetime import datetime
from typing import Optional, Dict, List, Tuple
from telegram import Update, ReplyKeyboardMarkup, ReplyKeyboardRemove
from telegram.ext import Application, CommandHandler, MessageHandler, ContextTypes, filters
import base64
from cryptography.fernet import Fernet
import hashlib

logging.basicConfig(format="%(asctime)s - %(name)s - %(levelname)s - %(message)s", level=logging.INFO)
logger = logging.getLogger(__name__)


def init_db():
    conn = sqlite3.connect('crypto_bot.db')
    cursor = conn.cursor()
    
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS user_history (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            user_id INTEGER,
            algorithm TEXT,
            operation TEXT,
            input_text TEXT,
            output_text TEXT,
            timestamp DATETIME
        )
    ''')
    
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS quiz_results (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            user_id INTEGER,
            score INTEGER,
            total INTEGER,
            correct INTEGER,
            date DATETIME
        )
    ''')
    
    conn.commit()
    conn.close()

init_db()

#################################################################################################### quest
CRYPTO_QUESTIONS = [
    {
        "question": "Что такое симметричное шифрование?",
        "options": [
            "Шифрование с одним ключом",
            "Шифрование с двумя ключами",
            "Шифрование без ключа",
            "Шифрование с открытым ключом"
        ],
        "correct": 0,
        "explanation": "Симметричное шифрование использует один ключ для шифрования и расшифрования.",
        "category": "Основы",
        "difficulty": "легкая"
    },
    {
        "question": "Что такое асимметричное шифрование?",
        "options": [
            "Шифрование с одним ключом",
            "Шифрование с парой ключей",
            "Шифрование без алгоритма",
            "Шифрование с фиксированным ключом"
        ],
        "correct": 1,
        "explanation": "Асимметричное шифрование использует пару ключей: публичный и приватный.",
        "category": "Основы",
        "difficulty": "легкая"
    },
    {
        "question": "Что такое криптография?",
        "options": [
            "Наука о тайнописи",
            "Наука о компьютерах",
            "Наука о сети",
            "Наука о данных"
        ],
        "correct": 0,
        "explanation": "Криптография - наука о методах обеспечения конфиденциальности и целостности данных.",
        "category": "Основы",
        "difficulty": "легкая"
    },
    {
        "question": "Какой алгоритм является симметричным?",
        "options": ["RSA", "AES", "ECC", "Diffie-Hellman"],
        "correct": 1,
        "explanation": "AES (Advanced Encryption Standard) - симметричный алгоритм шифрования.",
        "category": "Алгоритмы",
        "difficulty": "легкая"
    },
    {
        "question": "Какой алгоритм является асимметричным?",
        "options": ["AES", "DES", "Blowfish", "RSA"],
        "correct": 3,
        "explanation": "RSA - асимметричный алгоритм шифрования, использует пару ключей.",
        "category": "Алгоритмы",
        "difficulty": "легкая"
    },
    {
        "question": "Что такое XOR в криптографии?",
        "options": [
            "Хеш-функция",
            "Операция исключающего ИЛИ",
            "Асимметричный алгоритм",
            "Протокол обмена ключами"
        ],
        "correct": 1,
        "explanation": "XOR (исключающее ИЛИ) - бинарная операция, используемая в простых шифрах.",
        "category": "Алгоритмы",
        "difficulty": "легкая"
    },
    {
        "question": "Сколько раундов в AES-256?",
        "options": ["10", "12", "14", "16"],
        "correct": 2,
        "explanation": "AES-256 выполняет 14 раундов преобразований.",
        "category": "Алгоритмы",
        "difficulty": "средняя"
    },
    {
        "question": "Что такое шифр Цезаря?",
        "options": [
            "Шифр замены с фиксированным сдвигом",
            "Блочный шифр",
            "Хеш-функция",
            "Асимметричный алгоритм"
        ],
        "correct": 0,
        "explanation": "Шифр Цезаря - один из древнейших шифров с фиксированным сдвигом букв.",
        "category": "Алгоритмы",
        "difficulty": "легкая"
    },
    {
        "question": "Что такое SHA-256?",
        "options": [
            "Симметричный алгоритм шифрования",
            "Асимметричный алгоритм шифрования",
            "Хеш-функция",
            "Алгоритм подписи"
        ],
        "correct": 2,
        "explanation": "SHA-256 - криптографическая хеш-функция, создающая 256-битный хеш.",
        "category": "Хеширование",
        "difficulty": "легкая"
    },
    {
        "question": "Что такое хеш-функция?",
        "options": [
            "Алгоритм шифрования данных",
            "Функция преобразования данных в строку фиксированной длины",
            "Алгоритм обмена ключами",
            "Метод кодирования"
        ],
        "correct": 1,
        "explanation": "Хеш-функция преобразует данные произвольной длины в строку фиксированной длины.",
        "category": "Хеширование",
        "difficulty": "легкая"
    },
    {
        "question": "Можно ли восстановить исходные данные из хеша?",
        "options": [
            "Да, всегда",
            "Нет, это невозможно",
            "Только с ключом",
            "Только для коротких данных"
        ],
        "correct": 1,
        "explanation": "Хеш-функции являются односторонними, восстановить исходные данные из хеша невозможно.",
        "category": "Хеширование",
        "difficulty": "легкая"
    },
    {
        "question": "Что такое Base64?",
        "options": [
            "Алгоритм шифрования",
            "Система кодирования бинарных данных",
            "Хеш-функция",
            "Протокол передачи данных"
        ],
        "correct": 1,
        "explanation": "Base64 - система кодирования бинарных данных в текстовый формат ASCII.",
        "category": "Кодирование",
        "difficulty": "легкая"
    },
    {
        "question": "Для чего используется Base64?",
        "options": [
            "Для шифрования конфиденциальных данных",
            "Для передачи бинарных данных через текстовые протоколы",
            "Для сжатия данных",
            "Для создания цифровых подписей"
        ],
        "correct": 1,
        "explanation": "Base64 позволяет передавать бинарные данные через протоколы, работающие только с текстом.",
        "category": "Кодирование",
        "difficulty": "средняя"
    },
    {
        "question": "Кто создал алгоритм RSA?",
        "options": [
            "Алан Тьюринг",
            "Ривест, Шамир и Адлеман",
            "Брюс Шнайер",
            "Уитфилд Диффи"
        ],
        "correct": 1,
        "explanation": "RSA создан в 1977 году Ривестом, Шамиром и Адлеманом.",
        "category": "История",
        "difficulty": "легкая"
    },
    {
        "question": "Когда был изобретен алгоритм RSA?",
        "options": ["1967", "1977", "1987", "1997"],
        "correct": 1,
        "explanation": "Алгоритм RSA был изобретен в 1977 году.",
        "category": "История",
        "difficulty": "легкая"
    },
    {
        "question": "Что означает аббревиатура AES?",
        "options": [
            "Advanced Encryption Standard",
            "Asymmetric Encryption System",
            "Automated Encryption Service",
            "Applied Encryption Scheme"
        ],
        "correct": 0,
        "explanation": "AES означает Advanced Encryption Standard (Усовершенствованный стандарт шифрования).",
        "category": "История",
        "difficulty": "легкая"
    },
    {
        "question": "Где используется AES?",
        "options": [
            "Только в военных целях",
            "В HTTPS, VPN, Wi-Fi защите",
            "Только в банковских системах",
            "Только в мобильных приложениях"
        ],
        "correct": 1,
        "explanation": "AES используется в HTTPS, VPN, защите Wi-Fi (WPA2), и многих других системах.",
        "category": "Применение",
        "difficulty": "средняя"
    },
    {
        "question": "Какой протокол использует Telegram для шифрования?",
        "options": ["MTProto", "SSL", "IPSec", "WPA2"],
        "correct": 0,
        "explanation": "Telegram использует собственный протокол MTProto для шифрования сообщений.",
        "category": "Применение",
        "difficulty": "средняя"
    },
    {
        "question": "Для чего используется SSL/TLS?",
        "options": [
            "Для сжатия данных",
            "Для защиты интернет-соединений",
            "Для хеширования паролей",
            "Для кодирования видео"
        ],
        "correct": 1,
        "explanation": "SSL/TLS обеспечивает безопасную передачу данных в интернете.",
        "category": "Применение",
        "difficulty": "средняя"
    },
    {
        "question": "Что такое IV в криптографии?",
        "options": [
            "Initial Vector (Начальный вектор)",
            "Internal Variable",
            "Input Validator",
            "Integrity Verifier"
        ],
        "correct": 0,
        "explanation": "IV (Initialization Vector) используется для рандомизации шифрования.",
        "category": "Безопасность",
        "difficulty": "средняя"
    },
    {
        "question": "Что такое соль в криптографии?",
        "options": [
            "Случайные данные для хеширования",
            "Пароль пользователя",
            "Ключ шифрования",
            "Алгоритм подписи"
        ],
        "correct": 0,
        "explanation": "Соль (salt) добавляется к паролю перед хешированием для защиты от атак по радужным таблицам.",
        "category": "Безопасность",
        "difficulty": "средняя"
    },
    {
        "question": "Что такое цифровая подпись?",
        "options": [
            "Сканированная подпись",
            "Криптографическая аутентификация документа",
            "Пароль в базе данных",
            "Графический ключ"
        ],
        "correct": 1,
        "explanation": "Цифровая подпись подтверждает авторство и целостность электронного документа.",
        "category": "Безопасность",
        "difficulty": "средняя"
    },
    {
        "question": "Чем угрожают квантовые компьютеры криптографии?",
        "options": [
            "Ничем",
            "Всем алгоритмам одинаково",
            "В основном асимметричным алгоритмам",
            "Только хеш-функциям"
        ],
        "correct": 2,
        "explanation": "Квантовые компьютеры особенно опасны для асимметричных алгоритмов (RSA, ECC).",
        "category": "Современность",
        "difficulty": "сложная"
    },
    {
        "question": "Что такое постквантовая криптография?",
        "options": [
            "Криптография после изобретения квантовых компьютеров",
            "Алгоритмы, устойчивые к квантовым атакам",
            "Квантовая криптография",
            "Устаревшие алгоритмы"
        ],
        "correct": 1,
        "explanation": "Постквантовая криптография разрабатывает алгоритмы, устойчивые к атакам квантовых компьютеров.",
        "category": "Современность",
        "difficulty": "сложная"
    },
]

ADDITIONAL_QUESTIONS = [
    {
        "question": "Какой алгоритм использовался в стандарте DES?",
        "options": ["Алгоритм Фейстеля", "Алгоритм RSA", "Алгоритм Диффи-Хеллмана", "Алгоритм Эль-Гамаля"],
        "correct": 0,
        "explanation": "DES использует сеть Фейстеля с 16 раундами.",
        "category": "Алгоритмы",
        "difficulty": "средняя"
    },
    {
        "question": "Какой размер блока у алгоритма AES?",
        "options": ["64 бита", "128 бит", "256 бит", "512 бит"],
        "correct": 1,
        "explanation": "AES использует размер блока 128 бит независимо от длины ключа.",
        "category": "Алгоритмы",
        "difficulty": "средняя"
    },
    {
        "question": "Сколько всего вариантов ключей у шифра Цезаря с английским алфавитом?",
        "options": ["26", "25", "52", "24"],
        "correct": 1,
        "explanation": "В английском алфавите 26 букв, но сдвиг на 0 или 26 не меняет текст, поэтому 25 значимых вариантов.",
        "category": "Алгоритмы",
        "difficulty": "легкая"
    },
    {
        "question": "Какой протокол используется для безопасного просмотра веб-страниц?",
        "options": ["HTTP", "HTTPS", "FTP", "SMTP"],
        "correct": 1,
        "explanation": "HTTPS использует SSL/TLS для шифрования соединения.",
        "category": "Протоколы",
        "difficulty": "легкая"
    },
    {
        "question": "Что обеспечивает протокол SSL/TLS?",
        "options": ["Только шифрование", "Шифрование и аутентификацию", "Только аутентификацию", "Сжатие данных"],
        "correct": 1,
        "explanation": "SSL/TLS обеспечивает шифрование данных и аутентификацию сервера (а иногда и клиента).",
        "category": "Протоколы",
        "difficulty": "средняя"
    },
    {
        "question": "Какой порт обычно используется для HTTPS?",
        "options": ["80", "443", "8080", "21"],
        "correct": 1,
        "explanation": "Порт 443 стандартно используется для HTTPS соединений.",
        "category": "Протоколы",
        "difficulty": "легкая"
    },
    {
        "question": "Что такое HMAC?",
        "options": ["Хеш-функция", "Код аутентификации сообщений на основе хеша", "Алгоритм шифрования", "Протокол обмена ключами"],
        "correct": 1,
        "explanation": "HMAC использует криптографическую хеш-функцию и секретный ключ для проверки целостности и подлинности сообщения.",
        "category": "Хеширование",
        "difficulty": "средняя"
    },
    {
        "question": "Какой алгоритм считается устаревшим для хеширования паролей?",
        "options": ["SHA-256", "MD5", "bcrypt", "Argon2"],
        "correct": 1,
        "explanation": "MD5 считается криптографически нестойким и не должен использоваться для защиты паролей.",
        "category": "Хеширование",
        "difficulty": "средняя"
    },
    {
        "question": "Что такое 'радужная таблица' в контексте хеширования?",
        "options": ["Таблица цветов для интерфейса", "Предвычисленная таблица хешей для быстрого взлома", "Таблица случайных чисел", "Метод кодирования данных"],
        "correct": 1,
        "explanation": "Радужные таблицы позволяют быстро находить исходные данные по хешу методом предварительных вычислений.",
        "category": "Хеширование",
        "difficulty": "сложная"
    },
    {
        "question": "Что такое сеансовый ключ?",
        "options": ["Ключ, используемый постоянно", "Ключ, используемый для одной сессии", "Публичный ключ", "Мастер-ключ"],
        "correct": 1,
        "explanation": "Сеансовый ключ генерируется для одной сессии связи, что повышает безопасность.",
        "category": "Ключи",
        "difficulty": "средняя"
    },
    {
        "question": "Для чего используется центр сертификации (CA)?",
        "options": ["Для генерации случайных чисел", "Для проверки подлинности цифровых сертификатов", "Для шифрования данных", "Для хеширования паролей"],
        "correct": 1,
        "explanation": "Центры сертификации выдают и проверяют цифровые сертификаты, подтверждающие принадлежность публичного ключа владельцу.",
        "category": "Ключи",
        "difficulty": "средняя"
    },
    {
        "question": "Что такое атака по времени?",
        "options": ["Измерение времени выполнения операций для получения информации", "Атака с истекшим сроком действия", "Атака при переполнении времени", "Атака на системные часы"],
        "correct": 0,
        "explanation": "Атака по времени анализирует время, затраченное на криптографические операции, чтобы извлечь секретные данные.",
        "category": "Безопасность",
        "difficulty": "сложная"
    },
    {
        "question": "Что такое атака 'дней рождения'?",
        "options": ["Атака на систему праздников", "Взлом через социальную инженерию", "Нахождение коллизий хеш-функций", "Атака на генератор случайных чисел"],
        "correct": 2,
        "explanation": "Атака 'дней рождения' использует парадокс дней рождения для нахождения коллизий хеш-функций.",
        "category": "Безопасность",
        "difficulty": "сложная"
    },
    {
        "question": "Что такое блокчейн с криптографической точки зрения?",
        "options": ["База данных", "Распределенный реестр с криптографической защитой", "Серверная технология", "Облачное хранилище"],
        "correct": 1,
        "explanation": "Блокчейн - это распределенный реестр, где блоки связаны криптографически через хеши.",
        "category": "Современность",
        "difficulty": "средняя"
    },
    {
        "question": "Как называется криптовалюта, созданная анонимным разработчиком?",
        "options": ["Bitcoin", "Ethereum", "Litecoin", "Dogecoin"],
        "correct": 0,
        "explanation": "Bitcoin был создан анонимным разработчиком (или группой) под псевдонимом Сатоши Накамото.",
        "category": "Современность",
        "difficulty": "легкая"
    },
    {
        "question": "На какой математической задаче основана безопасность RSA?",
        "options": ["Задача дискретного логарифмирования", "Задача факторизации больших чисел", "Задача об укладке рюкзака", "Задача вычисления квадратного корня"],
        "correct": 1,
        "explanation": "RSA основан на сложности факторизации больших целых чисел.",
        "category": "Математика",
        "difficulty": "средняя"
    },
    {
        "question": "Что такое простое число в криптографии?",
        "options": ["Число, делящееся на 1 и само себя", "Число, делящееся только на 1 и само себя", "Число с многими делителями", "Четное число"],
        "correct": 1,
        "explanation": "Простое число имеет ровно два различных делителя: 1 и само себя.",
        "category": "Математика",
        "difficulty": "легкая"
    },
    {
        "question": "Какой режим шифрования AES наиболее простой, но наименее безопасный?",
        "options": ["ECB", "CBC", "CTR", "GCM"],
        "correct": 0,
        "explanation": "ECB (Electronic Codebook) - самый простой режим, но он не скрывает паттерны в данных.",
        "category": "Режимы",
        "difficulty": "средняя"
    },
    {
        "question": "Что такое вектор инициализации (IV)?",
        "options": ["Ключ шифрования", "Случайные данные для начала шифрования", "Пароль пользователя", "Хеш-значение"],
        "correct": 1,
        "explanation": "Вектор инициализации - это случайные данные, используемые для начала процесса шифрования, чтобы обеспечить уникальность шифротекста.",
        "category": "Режимы",
        "difficulty": "средняя"
    },
    {
        "question": "Какой алгоритм используется в WiFi защите WPA2?",
        "options": ["AES", "DES", "RC4", "Blowfish"],
        "correct": 0,
        "explanation": "WPA2 использует алгоритм AES для шифрования данных.",
        "category": "Применение",
        "difficulty": "средняя"
    },
    {
        "question": "Что такое двухфакторная аутентификация?",
        "options": [
            "Использование двух паролей",
            "Использование двух разных типов аутентификации",
            "Вход с двух устройств",
            "Двойное шифрование"
        ],
        "correct": 1,
        "explanation": "Двухфакторная аутентификация требует два различных типа доказательств (например, пароль и код из SMS).",
        "category": "Применение",
        "difficulty": "легкая"
    },
    {
        "question": "Кто из этих ученых известен работой над шифрованием во время Второй мировой войны?",
        "options": ["Алан Тьюринг", "Альберт Эйнштейн", "Никола Тесла", "Исаак Ньютон"],
        "correct": 0,
        "explanation": "Алан Тьюринг работал над взломом немецкого шифра 'Энигма' во время Второй мировой войны.",
        "category": "История",
        "difficulty": "легкая"
    },
    {
        "question": "Как называлась немецкая шифровальная машина времен Второй мировой?",
        "options": ["Энигма", "Лоренц", "Хеймдалль", "Валькирия"],
        "correct": 0,
        "explanation": "Энигма - роторная шифровальная машина, использовавшаяся Германией.",
        "category": "История",
        "difficulty": "легкая"
    },
    {
        "question": "Что такое цифровой сертификат?",
        "options": [
            "Электронный документ, подтверждающий права",
            "Электронный документ, удостоверяющий владение публичным ключом",
            "Лицензия на программное обеспечение",
            "Электронная подпись документа"
        ],
        "correct": 1,
        "explanation": "Цифровой сертификат связывает публичный ключ с идентификатором владельца и подписан центром сертификации.",
        "category": "Практика",
        "difficulty": "средняя"
    },
    {
        "question": "Что такое сквозное шифрование?",
        "options": [
            "Шифрование только на сервере",
            "Шифрование, при котором сообщения шифруются на устройстве отправителя и расшифровываются только на устройстве получателя",
            "Шифрование трафика между браузером и сервером",
            "Шифрование жесткого диска"
        ],
        "correct": 1,
        "explanation": "При сквозном шифровании данные шифруются на устройстве отправителя и могут быть расшифрованы только на устройстве получателя.",
        "category": "Практика",
        "difficulty": "средняя"
    },
    {
        "question": "Что такое криптографически стойкий генератор случайных чисел?",
        "options": [
            "Генератор, который быстро выдает числа",
            "Генератор, который выдает предсказуемые числа",
            "Генератор, выходные данные которого невозможно отличить от истинно случайных",
            "Генератор, основанный на системном времени"
        ],
        "correct": 2,
        "explanation": "Криптографически стойкий ГСЧ выдает последовательности, которые практически невозможно отличить от истинно случайных.",
        "category": "Безопасность",
        "difficulty": "средняя"
    },
    {
        "question": "Почему в криптографии важны случайные числа?",
        "options": [
            "Для красоты",
            "Для увеличения скорости",
            "Для обеспечения непредсказуемости ключей",
            "Для сжатия данных"
        ],
        "correct": 2,
        "explanation": "Случайные числа используются для генерации ключей, чтобы сделать их непредсказуемыми для злоумышленников.",
        "category": "Безопасность",
        "difficulty": "легкая"
    },
    {
        "question": "Что такое эллиптическая криптография?",
        "options": [
            "Криптография на основе эллиптических кривых",
            "Криптография с овальными ключами",
            "Криптография с использованием окружностей",
            "Геометрическая криптография"
        ],
        "correct": 0,
        "explanation": "Эллиптическая криптография использует алгебраическую структуру эллиптических кривых над конечными полями.",
        "category": "Алгоритмы",
        "difficulty": "сложная"
    },
    {
        "question": "Какое преимущество у ECC перед RSA?",
        "options": [
            "Более высокая скорость при той же стойкости",
            "Более простые вычисления",
            "Не требует случайных чисел",
            "Использует меньшие ключи при той же стойкости"
        ],
        "correct": 3,
        "explanation": "ECC обеспечивает ту же криптографическую стойкость при меньшей длине ключа по сравнению с RSA.",
        "category": "Алгоритмы",
        "difficulty": "средняя"
    },
    {
        "question": "Чем отличается стеганография от криптографии?",
        "options": [
            "Стеганография скрывает факт передачи сообщения, а криптография - его содержание",
            "Стеганография шифрует сообщения, а криптография их скрывает",
            "Это одно и то же",
            "Стеганография проще криптографии"
        ],
        "correct": 0,
        "explanation": "Стеганография скрывает само существование сообщения, в то время как криптография делает сообщение нечитаемым без ключа.",
        "category": "Основы",
        "difficulty": "средняя"
    },
    {
        "question": "Что такое квантовая криптография?",
        "options": [
            "Криптография с использованием квантовых компьютеров",
            "Криптография, основанная на принципах квантовой механики",
            "Криптография для квантовых физиков",
            "Сверхбыстрая криптография"
        ],
        "correct": 1,
        "explanation": "Квантовая криптография использует принципы квантовой механики для защиты связи.",
        "category": "Современность",
        "difficulty": "сложная"
    },
    {
        "question": "Какой протокол квантового распределения ключей наиболее известен?",
        "options": ["BB84", "RSA", "AES", "DH"],
        "correct": 0,
        "explanation": "BB84 - первый и наиболее известный протокол квантового распределения ключей, предложенный Беннетом и Брассардом в 1984 году.",
        "category": "Современность",
        "difficulty": "сложная"
    },
    {
        "question": "Что такое экспортный контроль криптографии?",
        "options": [
            "Запрет на использование криптографии",
            "Ограничение на экспорт криптографического программного обеспечения и оборудования",
            "Контроль над импортом криптовалют",
            "Регулирование использования криптографии внутри страны"
        ],
        "correct": 1,
        "explanation": "Многие страны ограничивают экспорт криптографических технологий из соображений национальной безопасности.",
        "category": "Практика",
        "difficulty": "средняя"
    },
    {
        "question": "Что такое постквантовая криптография?",
        "options": [
            "Криптография после изобретения квантовых компьютеров",
            "Криптографические алгоритмы, устойчивые к атакам квантовых компьютеров",
            "Криптография, использующая квантовые компьютеры",
            "Криптография будущего"
        ],
        "correct": 1,
        "explanation": "Постквантовая криптография разрабатывает алгоритмы, которые останутся стойкими даже при наличии квантовых компьютеров.",
        "category": "Современность",
        "difficulty": "средняя"
    },
    {
        "question": "Какой тип алгоритмов рассматривается для постквантовой криптографии?",
        "options": [
            "Алгоритмы на основе решеток",
            "Алгоритмы на основе факторизации",
            "Алгоритмы на основе дискретного логарифма",
            "Все вышеперечисленные"
        ],
        "correct": 0,
        "explanation": "Криптография на решетках считается перспективным направлением для постквантовой криптографии.",
        "category": "Современность",
        "difficulty": "сложная"
    },
    {
        "question": "Что такое криптографическая 'соль' при хешировании паролей?",
        "options": [
            "Дополнительные символы, добавляемые к паролю перед хешированием",
            "Метод шифрования пароля",
            "Алгоритм хеширования",
            "Ключ для расшифровки пароля"
        ],
        "correct": 0,
        "explanation": "Соль - это случайные данные, добавляемые к паролю перед хешированием, чтобы предотвратить атаки по радужным таблицам.",
        "category": "Хеширование",
        "difficulty": "средняя"
    },
    {
        "question": "Что такое 'песочница' в контексте безопасности?",
        "options": [
            "Игровая площадка",
            "Изолированная среда для выполнения непроверенного кода",
            "Место для хранения ключей",
            "Аппаратный модуль безопасности"
        ],
        "correct": 1,
        "explanation": "Песочница - это изолированная среда, в которой можно безопасно запускать непроверенный код.",
        "category": "Безопасность",
        "difficulty": "средняя"
    },
    {
        "question": "Что такое аппаратный модуль безопасности (HSM)?",
        "options": [
            "Специализированное устройство для управления ключами",
            "Аппаратный файрвол",
            "Сервер для хранения паролей",
            "Устройство для майнинга криптовалют"
        ],
        "correct": 0,
        "explanation": "HSM - это физическое устройство, которое защищает криптографические ключи и выполняет криптографические операции.",
        "category": "Безопасность",
        "difficulty": "средняя"
    },
    {
        "question": "Что такое закрытый ключ в асимметричной криптографии?",
        "options": [
            "Ключ, который хранится в секрете",
            "Ключ, который можно публиковать",
            "Ключ для кодирования",
            "Ключ для хеширования"
        ],
        "correct": 0,
        "explanation": "Закрытый (приватный) ключ хранится в секрете и используется для расшифровки или подписи.",
        "category": "Основы",
        "difficulty": "легкая"
    },
    {
        "question": "Что такое открытый ключ в асимметричной криптографии?",
        "options": [
            "Ключ, который хранится в секрете",
            "Ключ, который можно свободно распространять",
            "Ключ для расшифровки",
            "Ключ для подписи"
        ],
        "correct": 1,
        "explanation": "Открытый (публичный) ключ можно свободно распространять и использовать для шифрования или проверки подписи.",
        "category": "Основы",
        "difficulty": "легкая"
    },
    {
        "question": "Какой алгоритм симметричного шифрования стал преемником DES?",
        "options": ["AES", "RSA", "Blowfish", "Twofish"],
        "correct": 0,
        "explanation": "AES был выбран в 2001 году как новый стандарт симметричного шифрования вместо DES.",
        "category": "Алгоритмы",
        "difficulty": "легкая"
    },
    {
        "question": "Какой размер ключа у алгоритма DES?",
        "options": ["56 бит", "64 бита", "128 бит", "256 бит"],
        "correct": 0,
        "explanation": "DES использует ключ длиной 56 бит (хотя общая длина 64 бита, 8 бит используются для контроля четности).",
        "category": "Алгоритмы",
        "difficulty": "средняя"
    },
    {
        "question": "Что такое 'холодное хранилище' для криптовалют?",
        "options": [
            "Хранение ключей на устройстве, не подключенном к интернету",
            "Хранение на жестком диске",
            "Хранение в оперативной памяти",
            "Хранение в облаке"
        ],
        "correct": 0,
        "explanation": "Холодное хранилище означает хранение криптографических ключей на устройстве, не имеющем доступа к интернету.",
        "category": "Применение",
        "difficulty": "средняя"
    },
    {
        "question": "Что такое 'горячий кошелек' для криптовалют?",
        "options": [
            "Кошелек на устройстве, подключенном к интернету",
            "Кошелек с высокой температурой",
            "Кошелек для горячих сделок",
            "Кошелек с быстрым доступом"
        ],
        "correct": 0,
        "explanation": "Горячий кошелек хранит ключи на устройстве, подключенном к интернету, что удобно для частых операций, но менее безопасно.",
        "category": "Применение",
        "difficulty": "средняя"
    },
    {
        "question": "Можно ли использовать Base64 для шифрования конфиденциальных данных?",
        "options": [
            "Да, это надежный алгоритм",
            "Нет, это не шифрование, а кодирование",
            "Только с дополнительным ключом",
            "Только для коротких сообщений"
        ],
        "correct": 1,
        "explanation": "Base64 - это кодирование, а не шифрование. Любой может декодировать Base64 без ключа.",
        "category": "Кодирование",
        "difficulty": "легкая"
    },
    {
        "question": "Что такое 'криптографическая стойкость'?",
        "options": [
            "Стойкость алгоритма к физическим повреждениям",
            "Стойкость к криптоанализу при современных вычислительных возможностях",
            "Стойкость к высоким температурам",
            "Стойкость к электромагнитным помехам"
        ],
        "correct": 1,
        "explanation": "Криптографическая стойкость - способность алгоритма противостоять атакам при текущем уровне технологий.",
        "category": "Основы",
        "difficulty": "легкая"
    },
]

# Объединяем все вопросы
CRYPTO_QUESTIONS.extend(ADDITIONAL_QUESTIONS)
additional_questions = [
    {
        "question": "Какой размер ключа у AES-256?",
        "options": ["128 бит", "192 бита", "256 бит", "512 бит"],
        "correct": 2,
        "explanation": "AES-256 использует ключ длиной 256 бит.",
        "category": "Алгоритмы",
        "difficulty": "легкая"
    },
    {
        "question": "Что такое режим CBC в AES?",
        "options": [
            "Cipher Block Chaining",
            "Code Block Cipher",
            "Crypto Block Chain",
            "Cipher Byte Code"
        ],
        "correct": 0,
        "explanation": "CBC (Cipher Block Chaining) - режим сцепления блоков шифротекста.",
        "category": "Алгоритмы",
        "difficulty": "средняя"
    },
    {
        "question": "Что такое алгоритм Диффи-Хеллмана?",
        "options": [
            "Алгоритм шифрования",
            "Протокол обмена ключами",
            "Хеш-функция",
            "Алгоритм подписи"
        ],
        "correct": 1,
        "explanation": "Диффи-Хеллман позволяет двум сторонам создать общий секретный ключ по незащищенному каналу.",
        "category": "Алгоритмы",
        "difficulty": "средняя"
    },
    {
        "question": "Что такое PGP?",
        "options": [
            "Pretty Good Privacy",
            "Perfect Government Protocol",
            "Private Gateway Protection",
            "Public Key Gateway"
        ],
        "correct": 0,
        "explanation": "PGP (Pretty Good Privacy) - программа для шифрования и подписи данных.",
        "category": "Применение",
        "difficulty": "средняя"
    },
    {
        "question": "Для чего используется алгоритм SHA-256 в Bitcoin?",
        "options": [
            "Для шифрования транзакций",
            "Для создания хешей блоков",
            "Для подписи транзакций",
            "Для обмена ключами"
        ],
        "correct": 1,
        "explanation": "В Bitcoin SHA-256 используется для создания хешей блоков в блокчейне.",
        "category": "Применение",
        "difficulty": "средняя"
    },
    {
        "question": "Что такое атака 'человек посередине'?",
        "options": [
            "Атака на сервер",
            "Перехват и подмена сообщений",
            "Подбор пароля",
            "DDOS-атака"
        ],
        "correct": 1,
        "explanation": "Атака 'человек посередине' предполагает перехват и возможную подмену сообщений между сторонами.",
        "category": "Безопасность",
        "difficulty": "средняя"
    },
    {
        "question": "Что такое Perfect Forward Secrecy?",
        "options": [
            "Совершенная секретность в будущем",
            "Невозможность расшифровать старые сообщения при компрометации ключа",
            "Абсолютная защита от всех атак",
            "Шифрование без ключа"
        ],
        "correct": 1,
        "explanation": "PFS гарантирует, что компрометация долговременных ключей не приведет к раскрытию старых сессий.",
        "category": "Безопасность",
        "difficulty": "сложная"
    },
    {
        "question": "Что такое стеганография?",
        "options": [
            "Наука о шифрах",
            "Скрытие информации в других данных",
            "Анализ трафика",
            "Создание паролей"
        ],
        "correct": 1,
        "explanation": "Стеганография - скрытие факта передачи информации (в отличие от криптографии, которая скрывает содержание).",
        "category": "Основы",
        "difficulty": "средняя"
    },
    {
        "question": "Что такое криптоанализ?",
        "options": [
            "Создание алгоритмов шифрования",
            "Анализ и взлом шифров",
            "Защита данных",
            "Генерация ключей"
        ],
        "correct": 1,
        "explanation": "Криптоанализ - наука о методах взлома шифров и криптографических систем.",
        "category": "Основы",
        "difficulty": "средняя"
    },
]
CRYPTO_QUESTIONS.extend(additional_questions)

MAIN_KEYBOARD = ReplyKeyboardMarkup([
    ["🔐 Шифровать", "🔓 Расшифровать"],
    ["📊 История", "❓ Викторина"],
    ["📖 Справка"]
], resize_keyboard=True)

ALGORITHM_KEYBOARD = ReplyKeyboardMarkup([
    ["🔷 XOR", "🔡 Цезарь"],
    ["⚡ AES-256", "#️⃣ SHA-256"],
    ["🔣 Base64", "⬅️ Назад"]
], resize_keyboard=True)

QUIZ_KEYBOARD = ReplyKeyboardMarkup([
    ["🎮 Начать викторину", "📊 Мои результаты"],
    ["⬅️ Назад"]
], resize_keyboard=True)

#################################################################################################### data
def save_to_history(user_id: int, algorithm: str, operation: str, input_text: str, output_text: str):
    try:
        conn = sqlite3.connect('crypto_bot.db')
        cursor = conn.cursor()
        cursor.execute('''
            INSERT INTO user_history (user_id, algorithm, operation, input_text, output_text, timestamp)
            VALUES (?, ?, ?, ?, ?, ?)
        ''', (user_id, algorithm, operation, input_text[:200], output_text[:200], datetime.now()))
        conn.commit()
        conn.close()
    except Exception as e:
        logger.error(f"Ошибка сохранения истории: {e}")

def get_user_history(user_id: int, limit: int = 5):
    try:
        conn = sqlite3.connect('crypto_bot.db')
        cursor = conn.cursor()
        cursor.execute('''
            SELECT algorithm, operation, input_text, output_text, timestamp
            FROM user_history 
            WHERE user_id = ? 
            ORDER BY timestamp DESC 
            LIMIT ?
        ''', (user_id, limit))
        history = cursor.fetchall()
        conn.close()
        return history
    except Exception as e:
        logger.error(f"Ошибка получения истории: {e}")
        return []

def save_quiz_result(user_id: int, score: int, total: int, correct: int):
    try:
        conn = sqlite3.connect('crypto_bot.db')
        cursor = conn.cursor()
        cursor.execute('''
            INSERT INTO quiz_results (user_id, score, total, correct, date)
            VALUES (?, ?, ?, ?, ?)
        ''', (user_id, score, total, correct, datetime.now()))
        conn.commit()
        conn.close()
    except Exception as e:
        logger.error(f"Ошибка сохранения результата викторины: {e}")

def get_quiz_results(user_id: int, limit: int = 5):
    try:
        conn = sqlite3.connect('crypto_bot.db')
        cursor = conn.cursor()
        cursor.execute('''
            SELECT score, total, correct, date
            FROM quiz_results 
            WHERE user_id = ? 
            ORDER BY date DESC 
            LIMIT ?
        ''', (user_id, limit))
        results = cursor.fetchall()
        conn.close()
        return results
    except Exception as e:
        logger.error(f"Ошибка получения результатов викторины: {e}")
        return []

#################################################################################################### алг шифр
def xor_cipher(text: str, key: int) -> str:
    result = []
    for char in text:
        result.append(chr(ord(char) ^ key))
    return ''.join(result)

def caesar_cipher(text: str, shift: int, decrypt: bool = False) -> str:
    if decrypt:
        shift = -shift
    
    result = []
    for char in text:
        if 'а' <= char <= 'я':
            base = ord('а')
            result.append(chr((ord(char) - base + shift) % 32 + base))
        elif 'А' <= char <= 'Я':
            base = ord('А')
            result.append(chr((ord(char) - base + shift) % 32 + base))
        elif 'a' <= char <= 'z':
            base = ord('a')
            result.append(chr((ord(char) - base + shift) % 26 + base))
        elif 'A' <= char <= 'Z':
            base = ord('A')
            result.append(chr((ord(char) - base + shift) % 26 + base))
        else:
            result.append(char)
    return ''.join(result)

def sha256_hash(text: str) -> str:
    return hashlib.sha256(text.encode()).hexdigest()

def base64_encode(text: str) -> str:
    return base64.b64encode(text.encode()).decode()

def base64_decode(text: str) -> str:
    try:
        return base64.b64decode(text.encode()).decode()
    except:
        return None

def generate_aes_key() -> str:
    return Fernet.generate_key().decode()

def aes_encrypt(text: str, key: str) -> Optional[str]:
    try:
        fernet = Fernet(key.encode())
        encrypted = fernet.encrypt(text.encode())
        return base64.b64encode(encrypted).decode()
    except:
        return None

def aes_decrypt(encrypted_text: str, key: str) -> Optional[str]:
    try:
        fernet = Fernet(key.encode())
        encrypted_data = base64.b64decode(encrypted_text.encode())
        return fernet.decrypt(encrypted_data).decode()
    except:
        return None

# ==================== ОСНОВНЫЕ КОМАНДЫ ====================
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text(
        "🔐 *CodeBot*\n\n"
        "Изучайте современные методы шифрования на практике!\n\n"
        "Выберите действие:",
        parse_mode='Markdown',
        reply_markup=MAIN_KEYBOARD
    )

async def help_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    help_text = (
        "📖 *Справка*\n\n"
        "*Доступные функции:*\n\n"
        "🔐 *Шифрование* - преобразует текст в нечитаемый вид\n"
        "• XOR - простейший симметричный шифр\n"
        "• Цезарь - классический шифр сдвига\n"
        "• AES-256 - современный стандарт\n"
        "• SHA-256 - хеширование (необратимое)\n"
        "• Base64 - кодирование (не шифрование)\n\n"
        "🔓 *Расшифрование* - восстанавливает исходный текст\n\n"
        "📊 *История* - ваши последние операции\n\n"
        "❓ *Викторина* - проверьте знания по криптографии\n\n"
        "Используйте кнопки для навигации."
    )
    await update.message.reply_text(help_text, parse_mode='Markdown', reply_markup=MAIN_KEYBOARD)

#################################################################################################### code/encode
async def handle_encrypt_decrypt(update: Update, context: ContextTypes.DEFAULT_TYPE):
    text = update.message.text
    
    if text == "🔐 Шифровать":
        context.user_data['operation'] = 'encrypt'
        await update.message.reply_text(
            "Выберите алгоритм для шифрования:",
            reply_markup=ALGORITHM_KEYBOARD
        )
    elif text == "🔓 Расшифровать":
        context.user_data['operation'] = 'decrypt'
        await update.message.reply_text(
            "Выберите алгоритм для дешифрования:",
            reply_markup=ALGORITHM_KEYBOARD
        )

async def handle_algorithm(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Обработка выбора алгоритма"""
    text = update.message.text
    
    if text == "⬅️ Назад":
        context.user_data.clear()
        await start(update, context)
        return
    
    algorithm_map = {
        "🔷 XOR": "xor",
        "🔡 Цезарь": "caesar",
        "⚡ AES-256": "aes",
        "#️⃣ SHA-256": "sha256",
        "🔣 Base64": "base64"
    }
    
    if text in algorithm_map:
        context.user_data['algorithm'] = algorithm_map[text]
        operation = context.user_data.get('operation', 'encrypt')
        
        if context.user_data['algorithm'] == 'sha256':
            # SHA-256 только для шифрования (хеширования)
            await update.message.reply_text(
                "Введите текст для хеширования SHA-256:",
                reply_markup=ReplyKeyboardRemove()
            )
        elif context.user_data['algorithm'] == 'aes' and operation == 'decrypt':
            await update.message.reply_text(
                "Введите зашифрованный текст и ключ через пробел:\n"
                "Пример: `зашифрованный_текст ваш_ключ`",
                parse_mode='Markdown',
                reply_markup=ReplyKeyboardRemove()
            )
        else:
            op_text = "шифрования" if operation == 'encrypt' else "дешифрования"
            await update.message.reply_text(
                f"Введите текст для {op_text} ({text}):",
                reply_markup=ReplyKeyboardRemove()
            )

#################################################################################################### обработка осн сообщ
async def handle_text(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Обработка текстового ввода"""
    user_id = update.effective_user.id
    user_input = update.message.text.strip()

    if context.user_data.get('quiz_active'):
        await handle_quiz_answer(update, context)
        return

    algorithm = context.user_data.get('algorithm')
    operation = context.user_data.get('operation', 'encrypt')
    
    if not algorithm:
        await update.message.reply_text(
            "Пожалуйста, выберите действие из меню.",
            reply_markup=MAIN_KEYBOARD
        )
        return
    
    try:
        result = None
        explanation = ""
        input_text = user_input
        
        if algorithm == 'xor':
            if 'xor_waiting_key' not in context.user_data:
                context.user_data['xor_waiting_key'] = True
                context.user_data['xor_text'] = user_input
                await update.message.reply_text(
                    "Введите ключ (число от 1 до 255):",
                    reply_markup=ReplyKeyboardRemove()
                )
                return
            
            key = int(user_input)
            if not 1 <= key <= 255:
                await update.message.reply_text(
                    "Ключ должен быть числом от 1 до 255! Попробуйте снова:",
                    reply_markup=ReplyKeyboardRemove()
                )
                return
            
            text_to_process = context.user_data['xor_text']
            result = xor_cipher(text_to_process, key)
            explanation = f"XOR {'шифрование' if operation == 'encrypt' else 'дешифрование'}, ключ: {key}"
            input_text = text_to_process
            
            del context.user_data['xor_waiting_key']
            del context.user_data['xor_text']
        
        elif algorithm == 'caesar':
            if 'caesar_waiting_shift' not in context.user_data:
                context.user_data['caesar_waiting_shift'] = True
                context.user_data['caesar_text'] = user_input
                await update.message.reply_text(
                    "Введите сдвиг (число от 1 до 25):",
                    reply_markup=ReplyKeyboardRemove()
                )
                return
            
            shift = int(user_input)
            if not 1 <= shift <= 25:
                await update.message.reply_text(
                    "Сдвиг должен быть числом от 1 до 25! Попробуйте снова:",
                    reply_markup=ReplyKeyboardRemove()
                )
                return
            
            text_to_process = context.user_data['caesar_text']
            result = caesar_cipher(text_to_process, shift, decrypt=(operation == 'decrypt'))
            explanation = f"Шифр Цезаря {'шифрование' if operation == 'encrypt' else 'дешифрование'}, сдвиг: {shift}"
            input_text = text_to_process

            del context.user_data['caesar_waiting_shift']
            del context.user_data['caesar_text']
        
        elif algorithm == 'aes':
            if operation == 'encrypt':
                key = generate_aes_key()
                encrypted = aes_encrypt(user_input, key)
                if encrypted:
                    result = encrypted
                    explanation = f"AES-256 шифрование\nКлюч: {key}"
                else:
                    raise ValueError("Ошибка при шифровании AES")
            else:
                parts = user_input.split()
                if len(parts) >= 2:
                    encrypted_text = parts[0]
                    key = ' '.join(parts[1:])
                    decrypted = aes_decrypt(encrypted_text, key)
                    if decrypted:
                        result = decrypted
                        explanation = "AES-256 дешифрование"
                        input_text = encrypted_text
                    else:
                        raise ValueError("Неверный ключ или шифротекст")
                else:
                    await update.message.reply_text(
                        "Введите зашифрованный текст и ключ через пробел!",
                        reply_markup=ReplyKeyboardRemove()
                    )
                    return
        
        elif algorithm == 'sha256':
            result = sha256_hash(user_input)
            explanation = "SHA-256 хеширование"

        elif algorithm == 'base64':
            if operation == 'encrypt':
                result = base64_encode(user_input)
                explanation = "Base64 кодирование"
            else:
                result = base64_decode(user_input)
                if result:
                    explanation = "Base64 декодирование"
                else:
                    raise ValueError("Неверный формат Base64")
        
        if result:
            response = f"{explanation}\n\n*Результат:*\n```\n{result}\n```"
            await update.message.reply_text(response, parse_mode='Markdown', reply_markup=MAIN_KEYBOARD)
            
            if algorithm != 'sha256':
                save_to_history(user_id, algorithm, operation, input_text[:100], str(result)[:100])

        context.user_data.clear()
        
    except ValueError as e:
        error_msg = str(e)
        await update.message.reply_text(
            f"❌ Ошибка: {error_msg}\nПопробуйте снова.",
            reply_markup=MAIN_KEYBOARD
        )
        context.user_data.clear()
    except Exception as e:
        logger.error(f"Ошибка обработки: {e}")
        await update.message.reply_text(
            "❌ Произошла ошибка. Попробуйте снова.",
            reply_markup=MAIN_KEYBOARD
        )
        context.user_data.clear()

async def show_history(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    history = get_user_history(user_id)
    
    if not history:
        await update.message.reply_text(
            "История операций пуста.",
            reply_markup=MAIN_KEYBOARD
        )
        return
    
    response = "📊 *История ваших операций:*\n\n"
    
    for i, (algorithm, operation, input_text, output_text, timestamp) in enumerate(history, 1):
        response += f"{i}. *{algorithm}* ({operation})\n"
        response += f"   Ввод: `{input_text[:30]}...`\n"
        response += f"   Вывод: `{output_text[:30]}...`\n"
        response += f"   Время: {timestamp[:16]}\n\n"
    
    response += f"Всего записей: {len(history)}"
    
    await update.message.reply_text(response, parse_mode='Markdown', reply_markup=MAIN_KEYBOARD)

#################################################################################################### обработка вопросов
async def show_quiz_menu(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text(
        "❓ *Викторина по криптографии*\n\n"
        "Проверьте свои знания!\n\n"
        "• 10 случайных вопросов\n"
        "• +10 очков за правильный ответ\n"
        "• Максимум 100 очков\n\n"
        "Выберите действие:",
        parse_mode='Markdown',
        reply_markup=QUIZ_KEYBOARD
    )

async def start_quiz(update: Update, context: ContextTypes.DEFAULT_TYPE):
    questions = random.sample(CRYPTO_QUESTIONS, min(10, len(CRYPTO_QUESTIONS)))
    context.user_data['quiz_active'] = True
    context.user_data['quiz_questions'] = questions
    context.user_data['quiz_current'] = 0
    context.user_data['quiz_score'] = 0
    context.user_data['quiz_correct'] = 0
    
    await ask_quiz_question(update, context)

async def ask_quiz_question(update: Update, context: ContextTypes.DEFAULT_TYPE):
    questions = context.user_data['quiz_questions']
    current = context.user_data['quiz_current']
    
    if current >= len(questions):
        await finish_quiz(update, context)
        return
    
    question_data = questions[current]
    keyboard = []
    for i, option in enumerate(question_data['options']):
        keyboard.append([f"{i+1}. {option}"])
    
    keyboard.append(["🏁 Завершить викторину"])
    reply_markup = ReplyKeyboardMarkup(keyboard, resize_keyboard=True)
    
    question_text = (
        f"❓ *Вопрос {current + 1}/{len(questions)}*\n"
        f"📊 Сложность: {question_data['difficulty']}\n"
        f"🏆 Очков: {context.user_data['quiz_score']}\n\n"
        f"{question_data['question']}\n\n"
        f"Выберите правильный ответ:"
    )
    
    await update.message.reply_text(question_text, parse_mode='Markdown', reply_markup=reply_markup)

async def handle_quiz_answer(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not context.user_data.get('quiz_active'):
        await update.message.reply_text(
            "Сейчас нет активной викторины.",
            reply_markup=QUIZ_KEYBOARD
        )
        return
    
    text = update.message.text
    
    if text == "🏁 Завершить викторину":
        await finish_quiz(update, context, interrupted=True)
        return
    
    try:
        answer_num = int(text[0]) - 1
        questions = context.user_data['quiz_questions']
        current = context.user_data['quiz_current']
        correct_idx = questions[current]['correct']
        
        if 0 <= answer_num < len(questions[current]['options']):
            is_correct = (answer_num == correct_idx)
            
            if is_correct:
                context.user_data['quiz_score'] += 10
                context.user_data['quiz_correct'] += 1
                feedback = f"✅ *Правильно! +10 очков*\n\n{questions[current]['explanation']}"
            else:
                correct_answer = questions[current]['options'][correct_idx]
                feedback = f"❌ *Неправильно*\n\nПравильный ответ: {correct_answer}\n\n{questions[current]['explanation']}"

            context.user_data['quiz_current'] += 1

            await update.message.reply_text(feedback, parse_mode='Markdown')
            await asyncio.sleep(2)
            await ask_quiz_question(update, context)
        else:
            await update.message.reply_text(
                "Пожалуйста, выберите номер ответа из предложенных вариантов."
            )
            
    except (ValueError, IndexError):
        await update.message.reply_text(
            "Пожалуйста, выберите номер ответа из предложенных вариантов."
        )

async def finish_quiz(update: Update, context: ContextTypes.DEFAULT_TYPE, interrupted: bool = False):
    user_id = update.effective_user.id
    score = context.user_data.get('quiz_score', 0)
    correct = context.user_data.get('quiz_correct', 0)
    total = len(context.user_data.get('quiz_questions', []))
    
    if interrupted:
        result_text = (
            f"🏁 *Викторина прервана*\n\n"
            f"Отвечено вопросов: {context.user_data.get('quiz_current', 0)} из {total}\n"
            f"🏆 Набрано очков: {score}\n\n"
            f"Для новой викторины нажмите '🎮 Начать викторину'"
        )
    else:
        save_quiz_result(user_id, score, total * 10, correct)
        
        percentage = (score / (total * 10) * 100) if total > 0 else 0
        if percentage >= 90:
            grade = "Отлично! 🎉"
        elif percentage >= 70:
            grade = "Хорошо! 👍"
        elif percentage >= 50:
            grade = "Удовлетворительно 🙂"
        else:
            grade = "Попробуйте еще раз 💪"
        
        result_text = (
            f"🎉 *Викторина завершена!*\n\n"
            f"🏆 Ваш результат: {score} из {total * 10} очков\n"
            f"📊 Правильных ответов: {correct} из {total}\n"
            f"📈 Процент правильных: {percentage:.1f}%\n"
            f"📝 Оценка: {grade}\n\n"
            f"Ваш результат сохранен."
        )
    
    await update.message.reply_text(result_text, parse_mode='Markdown', reply_markup=QUIZ_KEYBOARD)
    for key in ['quiz_active', 'quiz_questions', 'quiz_current', 'quiz_score', 'quiz_correct']:
        if key in context.user_data:
            del context.user_data[key]

async def show_quiz_results(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    results = get_quiz_results(user_id)
    
    if not results:
        await update.message.reply_text(
            "📊 У вас пока нет результатов викторин.\n"
            "Пройдите викторину, чтобы увидеть здесь свои результаты!",
            reply_markup=QUIZ_KEYBOARD
        )
        return
    
    response = "📊 *Ваши результаты викторин:*\n\n"
    
    for i, (score, total, correct, date) in enumerate(results, 1):
        percentage = (score / total * 100) if total > 0 else 0
        date_str = date[:16]
        response += f"{i}. {score}/{total} очков ({correct} правильных)\n"
        response += f"   {percentage:.1f}% - {date_str}\n\n"
    
    total_score = sum(r[0] for r in results)
    total_max = sum(r[1] for r in results)
    total_correct = sum(r[2] for r in results)
    total_questions = len(results) * 10 if results else 0
    
    if total_questions > 0:
        avg_percentage = (total_score / total_max * 100) if total_max > 0 else 0
        response += f"📈 *Общая статистика:*\n"
        response += f"• Всего викторин: {len(results)}\n"
        response += f"• Средний результат: {avg_percentage:.1f}%\n"
        response += f"• Всего очков: {total_score}\n"
        response += f"• Правильных ответов: {total_correct}"
    
    await update.message.reply_text(response, parse_mode='Markdown', reply_markup=QUIZ_KEYBOARD)

#################################################################################################### осн обработка
async def handle_all_messages(update: Update, context: ContextTypes.DEFAULT_TYPE):
    text = update.message.text
    if text == "📖 Справка":
        await help_command(update, context)
    elif text == "📊 История":
        await show_history(update, context)
    elif text == "❓ Викторина":
        await show_quiz_menu(update, context)
    elif text in ["🔐 Шифровать", "🔓 Расшифровать"]:
        await handle_encrypt_decrypt(update, context)
    elif text in ["🔷 XOR", "🔡 Цезарь", "⚡ AES-256", "#️⃣ SHA-256", "🔣 Base64", "⬅️ Назад"]:
        await handle_algorithm(update, context)
    elif text in ["🎮 Начать викторину", "📊 Мои результаты", "⬅️ Назад"]:
        if text == "🎮 Начать викторину":
            await start_quiz(update, context)
        elif text == "📊 Мои результаты":
            await show_quiz_results(update, context)
        elif text == "⬅️ Назад":
            context.user_data.clear()
            await start(update, context)
    else:
        await handle_text(update, context)

def main():
    """Запуск бота"""
    TOKEN = "8"
    
    app = Application.builder().token(TOKEN).build()
    app.add_handler(CommandHandler("start", start))
    app.add_handler(CommandHandler("help", help_command))
    
    app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_all_messages))
    #sys()
    app.run_polling()
if __name__ == "__main__":
    main()
